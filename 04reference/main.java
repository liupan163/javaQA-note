//一、强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？

//强引用：
我们平常典型编码Object obj = new Object()中的obj就是强引用。  通过关键字new创建的对象所关联的引用就是强引用。当JVM内存不足时，
JVM宁愿跑出OutOfMemoryErro运行时错误OOM，使程序异常终止，也不会靠随意回收具有强引用的存活对象来解决内存不足的问题。
对于一个普通的对象，如果没有其他引用关系，只要超过了引用的作用域或者显示将强引用赋值为null，就是可以被垃圾收集的了，具体
回收实际还是要看垃圾收集策略。
//软引用
通过SoftReference类实现。当JVM认为内存不足时，才会去试图回收软引用指向的对象，即JVM会确保在跑出OutOfMemoryError之前，清理
软引用指向的对象。
软引用可以和一个引用队列联合使用，如果软引用所引用的对象被垃圾回收器回收，java虚拟机就会把这个软引用加入到与之关联的引用队列中。
后续，我们可以调用ReferenceQueue的poll（）方法来检查是否有他所关心的对象被回收。如果队列为空，将返回一个null，否则该方法返回
队列中前一个的Reference对象。

应用场景：软引用通常来实现内存敏感的缓存。  （图片）

//弱引用
弱引用通过WeakReference类实现。弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现具有弱引用
的对象，不管当前内存空间足够与否，都会回收，java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

//虚引用
虚引用也叫幻象引用。通过PhantomReference类来实现。无法通过虚拟引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被
finalize以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用
必须和引用队列ReferenceQueue联合使用。当垃圾回收器准备回收一个对象时，如过发现他还有虚引用，就会在回收对象内存前，把这个虚引用
加入到与之关联的引用队列中。
ReferenceQueue queue = new ReferenceQueue（）;
PhantomReference pr = new PhantomReference(object,queue);
程序可以通过判断引用队列中是否加入了虚引用，来了解被引用的对象是否要被垃圾回收。如果程序发现某个虚拟引用已经被加入到引用队列，
那么就可以在所引用的对象的内存被回收之前采取一些程序行动。
//应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。